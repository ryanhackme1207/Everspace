{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Multiplayer Battle - Everspace</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        /* Mode Selection Screen */
        .mode-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 80vh;
            gap: 30px;
        }

        .mode-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 20px;
        }

        .mode-buttons {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mode-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            width: 280px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-card:hover {
            transform: translateY(-10px) scale(1.05);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.4);
        }

        .mode-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .mode-name {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .mode-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.6;
        }

        /* Battle Arena */
        .battle-arena {
            display: none;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .arena-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .arena-title {
            font-size: 42px;
            font-weight: bold;
            background: linear-gradient(135deg, #ff6b6b, #f093fb);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .matchmaking-status {
            font-size: 18px;
            color: #f093fb;
            margin-top: 10px;
        }

        /* Battle Grid */
        .battle-grid {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 30px;
            align-items: start;
        }

        /* Player Panel */
        .player-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .player-info {
            text-align: center;
            margin-bottom: 20px;
        }

        .player-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            margin: 0 auto 15px;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .player-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-score {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Health Bar */
        .health-container {
            margin: 20px 0;
        }

        .health-label {
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .health-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.5s ease, background 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .health-fill.low {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }

        .health-fill.critical {
            background: linear-gradient(90deg, #ef4444, #dc2626);
            animation: healthPulse 1s ease-in-out infinite;
        }

        @keyframes healthPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Mini Board Preview */
        .mini-board {
            margin-top: 20px;
            animation: fadeInUp 0.5s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .mini-board-title {
            font-size: 16px;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .activity-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: blink 1s ease-in-out infinite;
            opacity: 0;
        }

        .activity-indicator.active {
            opacity: 1;
        }

        @keyframes blink {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .mini-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.2));
            padding: 10px;
            border-radius: 10px;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mini-grid:hover {
            transform: scale(1.02);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .mini-cell {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 900;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        .mini-cell:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* Mini cell colors matching main tiles */
        .mini-cell[data-value="2"] { background: #eee4da; color: #776e65; }
        .mini-cell[data-value="4"] { background: #ede0c8; color: #776e65; }
        .mini-cell[data-value="8"] { background: #f2b179; color: white; }
        .mini-cell[data-value="16"] { background: #f59563; color: white; }
        .mini-cell[data-value="32"] { background: #f67c5f; color: white; }
        .mini-cell[data-value="64"] { background: #f65e3b; color: white; }
        .mini-cell[data-value="128"] { background: #edcf72; color: white; font-size: 14px; }
        .mini-cell[data-value="256"] { background: #edcc61; color: white; font-size: 14px; }
        .mini-cell[data-value="512"] { background: #edc850; color: white; font-size: 14px; }
        .mini-cell[data-value="1024"] { background: #edc53f; color: white; font-size: 12px; }
        .mini-cell[data-value="2048"] { background: #edc22e; color: white; font-size: 12px; animation: mini-glow 2s ease-in-out infinite; }

        @keyframes mini-glow {
            0%, 100% { box-shadow: 0 2px 4px rgba(237, 194, 46, 0.5); }
            50% { box-shadow: 0 2px 8px rgba(237, 194, 46, 1), 0 0 12px rgba(237, 194, 46, 0.5); }
        }

        /* Main Game Board */
        .game-board-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .control-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .game-board {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 12px;
            display: inline-block;
            margin: 0 auto;
            display: block;
            width: fit-content;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 650px;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 56px;
            font-weight: 900;
            transition: all 0.15s ease;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .cell[data-value="2"] { background: #eee4da; color: #776e65; box-shadow: 0 4px 12px rgba(238, 228, 218, 0.5); }
        .cell[data-value="4"] { background: #ede0c8; color: #776e65; box-shadow: 0 4px 12px rgba(237, 224, 200, 0.5); }
        .cell[data-value="8"] { background: #f2b179; color: white; box-shadow: 0 4px 12px rgba(242, 177, 121, 0.5); }
        .cell[data-value="16"] { background: #f59563; color: white; box-shadow: 0 4px 12px rgba(245, 149, 99, 0.5); }
        .cell[data-value="32"] { background: #f67c5f; color: white; box-shadow: 0 4px 12px rgba(246, 124, 95, 0.5); }
        .cell[data-value="64"] { background: #f65e3b; color: white; box-shadow: 0 4px 12px rgba(246, 94, 59, 0.5); }
        .cell[data-value="128"] { background: #edcf72; color: white; font-size: 48px; box-shadow: 0 6px 16px rgba(237, 207, 114, 0.6); }
        .cell[data-value="256"] { background: #edcc61; color: white; font-size: 48px; box-shadow: 0 6px 16px rgba(237, 204, 97, 0.6); }
        .cell[data-value="512"] { background: #edc850; color: white; font-size: 48px; box-shadow: 0 6px 16px rgba(237, 200, 80, 0.6); }
        .cell[data-value="1024"] { background: #edc53f; color: white; font-size: 42px; box-shadow: 0 8px 20px rgba(237, 197, 63, 0.7); }
        .cell[data-value="2048"] { background: #edc22e; color: white; font-size: 42px; box-shadow: 0 8px 20px rgba(237, 194, 46, 0.7); animation: glow 1.5s ease-in-out infinite; }

        @keyframes glow {
            0%, 100% { box-shadow: 0 8px 20px rgba(237, 194, 46, 0.7); }
            50% { box-shadow: 0 8px 30px rgba(237, 194, 46, 1), 0 0 40px rgba(237, 194, 46, 0.5); }
        }

        /* Attack Animation */
        @keyframes attack {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .cell.attacking {
            animation: attack 0.4s ease;
        }

        /* Merge Animation */
        @keyframes merge-animation {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.2); filter: brightness(1.5); box-shadow: 0 0 30px currentColor; }
            100% { transform: scale(1); filter: brightness(1); }
        }

        .cell.merged {
            animation: merge-animation 0.3s ease;
        }

        /* Pop-in Animation for new tiles */
        @keyframes pop-in {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 1; }
        }

        .cell.new-tile {
            animation: pop-in 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* Slide Animation */
        @keyframes slide {
            0% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }

        .cell.sliding {
            animation: slide 0.15s ease;
        }

        /* Bomb Effect */
        .bomb-effect {
            position: fixed;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff6b6b, transparent);
            pointer-events: none;
            animation: bombExplosion 0.6s ease-out forwards;
            z-index: 1000;
        }

        @keyframes bombExplosion {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        /* Heal Effect */
        .heal-effect {
            position: fixed;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, #4ade80, transparent);
            pointer-events: none;
            animation: healPulse 0.6s ease-out forwards;
            z-index: 1000;
        }

        @keyframes healPulse {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        /* Damage Indicator */
        .damage-indicator {
            position: fixed;
            font-size: 48px;
            font-weight: bold;
            color: #ff6b6b;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
            z-index: 1001;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
        }

        @keyframes damageFloat {
            0% {
                transform: translateY(0) scale(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(1);
                opacity: 0;
            }
        }

        /* Heal Indicator */
        .heal-indicator {
            position: fixed;
            font-size: 36px;
            font-weight: bold;
            color: #4ade80;
            pointer-events: none;
            animation: healFloat 1s ease-out forwards;
            z-index: 1001;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.8);
        }

        @keyframes healFloat {
            0% {
                transform: translateY(0) scale(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-80px) scale(1);
                opacity: 0;
            }
        }

        /* Shake Animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Pulse Animation for Updates */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        /* Game Over Modal */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 24px;
            padding: 50px;
            text-align: center;
            border: 3px solid rgba(255, 255, 255, 0.2);
            max-width: 500px;
        }

        .modal-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .modal-title.victory {
            color: #4ade80;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.6);
        }

        .modal-title.defeat {
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.6);
        }

        .modal-stats {
            margin: 30px 0;
            font-size: 18px;
            line-height: 2;
        }

        .modal-rewards {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .reward-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .reward-item:last-child {
            border-bottom: none;
            font-size: 24px;
            font-weight: bold;
            color: #f59e0b;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .modal-btn {
            padding: 15px 35px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .modal-btn:hover {
            transform: scale(1.05);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .battle-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .player-panel:last-child .mini-board {
                display: none;
            }
        }

        .hidden {
            display: none !important;
        }

        /* Pulse animation for waiting room */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
        }
    </style>
</head>
<body>
    <!-- Mode Selection Screen -->
    <div class="mode-selection" id="modeSelection">
        <div>
            <h1 class="mode-title">üéÆ 2048 Game Mode</h1>
            <p style="text-align: center; opacity: 0.8;">Choose your battle style</p>
            <div style="text-align: center; margin-top: 10px; color: #4ade80; font-size: 0.9em;">
                <span id="onlineCount">0</span> players online
            </div>
        </div>
        
        <div class="mode-buttons">
            <div class="mode-card" onclick="startStandardMode()">
                <div class="mode-icon">üéØ</div>
                <div class="mode-name">Standard</div>
                <div class="mode-description">
                    Classic 2048 puzzle game. Merge tiles to reach 2048 and earn Evercoins based on your score.
                </div>
            </div>
            
            <div class="mode-card" onclick="startMultiplayerMode()">
                <div class="mode-icon">‚öîÔ∏è</div>
                <div class="mode-name">Multiplayer PvP</div>
                <div class="mode-description">
                    Battle against real players or AI! Merge tiles to attack opponents and be the last one standing.
                </div>
            </div>
        </div>
        
        <a href="#" onclick="closeGameWindow(); return false;" style="color: white; text-decoration: none; opacity: 0.7; margin-top: 20px;">
            ‚Üê Back to Chat
        </a>
    </div>

    <!-- Waiting Room -->
    <div class="mode-selection hidden" id="waitingRoom">
        <div style="text-align: center;">
            <h1 class="mode-title">üîç Finding Opponent...</h1>
            <div style="margin: 30px 0;">
                <div style="font-size: 48px; animation: pulse 1.5s ease-in-out infinite;">‚è≥</div>
            </div>
            <p style="opacity: 0.8; margin-bottom: 10px;">Searching for available players...</p>
            <div style="color: #4ade80; font-size: 1.1em; margin-bottom: 20px;">
                <span id="waitingOnlineCount">0</span> players online
            </div>
            <div style="color: #fbbf24; font-size: 0.9em; margin-bottom: 30px;">
                Waiting: <span id="waitTimer">0</span>s
            </div>
            
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button onclick="playWithBot()" style="padding: 12px 30px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 8px; font-size: 1em; cursor: pointer; transition: all 0.3s;">
                    ü§ñ Play with Bot Instead
                </button>
                <button onclick="cancelMatchmaking()" style="padding: 12px 30px; background: rgba(255, 255, 255, 0.1); color: white; border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 8px; font-size: 1em; cursor: pointer; transition: all 0.3s;">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Battle Arena (Multiplayer) -->
    <div class="battle-arena" id="battleArena">
        <div class="arena-header">
            <h1 class="arena-title">‚öîÔ∏è 2048 BATTLE ARENA ‚öîÔ∏è</h1>
            <div class="matchmaking-status" id="matchmakingStatus">Finding opponent...</div>
        </div>

        <div class="battle-grid">
            <!-- Player 1 (You) -->
            <div class="player-panel">
                <div class="player-info">
                    <div class="player-avatar">üë§</div>
                    <div class="player-name" id="player1Name">{{ user.username }}</div>
                    <div class="player-score">Score: <span id="player1Score">0</span></div>
                </div>
                
                <div class="health-container">
                    <div class="health-label">
                        <span>‚ù§Ô∏è Health</span>
                        <span id="player1HealthText">100%</span>
                    </div>
                    <div class="health-bar">
                        <div class="health-fill" id="player1HealthBar" style="width: 100%">100%</div>
                    </div>
                </div>
                
                <div class="mini-board">
                    <div class="mini-board-title">Your Board</div>
                    <div class="mini-grid" id="player1MiniBoard">
                        <!-- Mini tiles will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Main Game Board -->
            <div class="game-board-container">
                <div class="game-controls">
                    <button class="control-btn" onclick="forfeitGame()">Forfeit</button>
                    <div style="text-align: center;">
                        <div style="font-size: 32px; font-weight: bold; color: #f59e0b;">
                            <span id="yourScore">0</span>
                        </div>
                        <div style="font-size: 14px; opacity: 0.7;">Your Score</div>
                    </div>
                    <button class="control-btn" onclick="newGame()">New Game</button>
                </div>

                <div class="game-board">
                    <div class="grid" id="gameGrid">
                        <!-- Grid cells will be generated here -->
                    </div>
                </div>

                <div style="text-align: center; margin-top: 20px; color: rgba(255,255,255,0.6);">
                    Use arrow keys to play ‚Ä¢ Merge tiles to attack!
                </div>
            </div>

            <!-- Player 2 (Opponent) -->
            <div class="player-panel">
                <div class="player-info">
                    <div class="player-avatar">ü§ñ</div>
                    <div class="player-name" id="player2Name">Waiting...</div>
                    <div class="player-score">Score: <span id="player2Score">0</span></div>
                </div>
                
                <div class="health-container">
                    <div class="health-label">
                        <span>‚ù§Ô∏è Health</span>
                        <span id="player2HealthText">100%</span>
                    </div>
                    <div class="health-bar">
                        <div class="health-fill" id="player2HealthBar" style="width: 100%">100%</div>
                    </div>
                </div>
                
                <div class="mini-board">
                    <div class="mini-board-title">
                        <span>Opponent's Board</span>
                        <span class="activity-indicator" id="opponentActivity"></span>
                    </div>
                    <div class="mini-grid" id="player2MiniBoard">
                        <!-- Mini tiles will be generated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <div class="modal-title" id="modalTitle">Victory!</div>
            <div class="modal-stats" id="modalStats"></div>
            <div class="modal-rewards" id="modalRewards"></div>
            <div class="modal-buttons">
                <button class="modal-btn btn-primary" onclick="playAgain()">Play Again</button>
                <button class="modal-btn btn-secondary" onclick="backToMenu()">Back to Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Sound Effects using Web Audio API
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioContext();

        function playSound(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playMoveSound() {
            playSound(200, 0.1, 'square');
        }

        function playMergeSound(value) {
            // Higher value = higher pitch
            const frequency = 300 + (Math.log2(value) * 50);
            playSound(frequency, 0.15, 'sine');
        }

        function playVictorySound() {
            playSound(523.25, 0.2, 'sine'); // C5
            setTimeout(() => playSound(659.25, 0.2, 'sine'), 200); // E5
            setTimeout(() => playSound(783.99, 0.3, 'sine'), 400); // G5
        }

        function playDefeatSound() {
            playSound(200, 0.3, 'sawtooth');
            setTimeout(() => playSound(150, 0.3, 'sawtooth'), 150);
            setTimeout(() => playSound(100, 0.4, 'sawtooth'), 300);
        }

        // Global game state
        let gameMode = null; // 'standard' or 'multiplayer'
        let gameSocket = null;
        let currentGameId = null;
        let grid = [];
        let score = 0;
        let isBot = false;
        let player1Health = 100;
        let player2Health = 100;
        let gameStartTime = Date.now();

        // Initialize game
        function init() {
            grid = [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];
            score = 0;
            player1Health = 100;
            player2Health = 100;
            gameStartTime = Date.now();
            
            addRandomTile();
            addRandomTile();
            updateDisplay();
        }

        // Waiting room timer
        let waitTimer = 0;
        let waitTimerInterval = null;

        // Mode selection
        function startStandardMode() {
            // Hide mode selection and show battle arena for solo play
            gameMode = 'standard';
            document.getElementById('modeSelection').classList.add('hidden');
            document.getElementById('battleArena').style.display = 'block';
            
            // Hide opponent panel for standard mode
            document.querySelectorAll('.player-panel')[1].style.display = 'none';
            document.getElementById('matchmakingStatus').style.display = 'none';
            
            init();
        }

        function startMultiplayerMode() {
            gameMode = 'multiplayer';
            document.getElementById('modeSelection').classList.add('hidden');
            document.getElementById('waitingRoom').classList.remove('hidden');
            
            // Start wait timer
            waitTimer = 0;
            waitTimerInterval = setInterval(() => {
                waitTimer++;
                document.getElementById('waitTimer').textContent = waitTimer;
            }, 1000);
            
            init();
            initializeMultiplayer(true); // Wait for real player
        }

        function playWithBot() {
            // Cancel waiting and play with bot
            if (gameSocket) {
                gameSocket.close();
            }
            clearInterval(waitTimerInterval);
            
            document.getElementById('waitingRoom').classList.add('hidden');
            document.getElementById('battleArena').style.display = 'block';
            
            initializeMultiplayer(false); // Play with bot
        }

        function cancelMatchmaking() {
            // Cancel and go back to menu
            if (gameSocket) {
                gameSocket.close();
            }
            clearInterval(waitTimerInterval);
            
            document.getElementById('waitingRoom').classList.add('hidden');
            document.getElementById('modeSelection').classList.remove('hidden');
        }

        // Multiplayer WebSocket setup
        function initializeMultiplayer(waitForPlayer = true) {
            // Generate a temporary game ID
            currentGameId = 'temp_' + Date.now();
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/game2048/${currentGameId}/`;
            
            gameSocket = new WebSocket(wsUrl);
            
            gameSocket.onopen = function(e) {
                console.log('Connected to game server');
                // Try to find match or create bot game
                gameSocket.send(JSON.stringify({
                    type: 'find_match',
                    wait_for_player: waitForPlayer
                }));
            };
            
            gameSocket.onmessage = function(e) {
                const data = JSON.parse(e.data);
                handleWebSocketMessage(data);
            };
            
            gameSocket.onclose = function(e) {
                console.log('Disconnected from game server');
            };
            
            gameSocket.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'online_count':
                    // Update online count in both mode selection and waiting room
                    document.getElementById('onlineCount').textContent = data.count;
                    document.getElementById('waitingOnlineCount').textContent = data.count;
                    break;
                
                case 'waiting':
                    // Still waiting for opponent
                    console.log('Waiting for opponent:', data.message);
                    break;
                    
                case 'game_start':
                    // Stop wait timer
                    clearInterval(waitTimerInterval);
                    
                    // Hide waiting room, show battle arena
                    document.getElementById('waitingRoom').classList.add('hidden');
                    document.getElementById('battleArena').style.display = 'block';
                    
                    currentGameId = data.game_id;
                    isBot = data.is_bot;
                    document.getElementById('player2Name').textContent = data.player2;
                    document.getElementById('matchmakingStatus').textContent = `Battle started against ${data.player2}!`;
                    setTimeout(() => {
                        document.getElementById('matchmakingStatus').style.display = 'none';
                    }, 3000);
                    
                    // If playing against bot, start bot AI
                    if (isBot) {
                        console.log('ü§ñ Bot game started - Bot will make random moves');
                        startBotAI();
                    }
                    break;
                    
                case 'game_move':
                    handleOpponentMove(data);
                    break;
                    
                case 'game_victory':
                    handleGameEnd(data);
                    break;
                    
                case 'error':
                    console.error('Game error:', data.message);
                    break;
            }
        }

        function handleOpponentMove(data) {
            console.log('üéÆ Opponent move received:', data);
            
            // Show activity indicator
            const activityIndicator = document.getElementById('opponentActivity');
            if (activityIndicator) {
                activityIndicator.classList.add('active');
                setTimeout(() => {
                    activityIndicator.classList.remove('active');
                }, 2000);
            }
            
            // Update opponent's score with animation
            const scoreElement = document.getElementById('player2Score');
            scoreElement.textContent = data.score;
            scoreElement.style.transition = 'transform 0.3s ease';
            scoreElement.style.transform = 'scale(1.2)';
            setTimeout(() => {
                scoreElement.style.transform = 'scale(1)';
            }, 300);
            
            // Update mini board with animation
            updateMiniBoard('player2MiniBoard', data.board);
            
            // Animate the merged tiles on opponent's board
            if (data.merged_tiles && data.merged_tiles.length > 0) {
                console.log('üí• Opponent merged:', data.merged_tiles);
                highlightOpponentMerges(data.merged_tiles);
            }
            
            // Handle damage received (opponent attacked us)
            if (data.player !== '{{ user.username }}') {
                if (data.damage > 0) {
                    console.log('üíî We received damage:', data.damage, 'Health updates:', data.health_updates);
                    
                    // Update our health (we are opponent in this context)
                    if (data.health_updates.opponent_health !== undefined) {
                        player1Health = data.health_updates.opponent_health;
                        updateHealthBar('player1', player1Health);
                        showBombEffect(document.querySelector('#player1HealthBar'));
                        showDamageIndicator(`-${data.damage}%`, document.querySelector('.player-panel'));
                        
                        // Shake our health bar
                        const healthBar = document.querySelector('#player1HealthBar');
                        healthBar.parentElement.style.animation = 'shake 0.5s';
                        setTimeout(() => {
                            healthBar.parentElement.style.animation = '';
                        }, 500);
                        
                        // Check if we lost
                        if (player1Health <= 0) {
                            setTimeout(() => endGame(false), 1000);
                        }
                    }
                }
                
                // Handle opponent healing themselves
                if (data.heal > 0) {
                    console.log('üíö Opponent healed:', data.heal, 'Health updates:', data.health_updates);
                    
                    // Update opponent health (they healed themselves)
                    if (data.health_updates.your_health !== undefined) {
                        player2Health = data.health_updates.your_health;
                        updateHealthBar('player2', player2Health);
                        showHealEffect(document.querySelectorAll('.player-panel')[1]);
                        showHealIndicator(`+${data.heal}%`, document.querySelectorAll('.player-panel')[1]);
                    }
                }
            }
        }
        
        function highlightOpponentMerges(mergedTiles) {
            // Flash the opponent's mini board to show activity
            const miniBoard = document.getElementById('player2MiniBoard');
            miniBoard.style.transition = 'all 0.3s ease';
            miniBoard.style.transform = 'scale(1.1)';
            miniBoard.style.boxShadow = '0 0 20px rgba(255, 107, 107, 0.6)';
            
            setTimeout(() => {
                miniBoard.style.transform = 'scale(1)';
                miniBoard.style.boxShadow = '';
            }, 300);
            
            // Show which tiles were merged
            const cells = miniBoard.querySelectorAll('.mini-cell');
            mergedTiles.forEach(tileValue => {
                cells.forEach(cell => {
                    if (cell.textContent && parseInt(cell.getAttribute('data-value')) === tileValue) {
                        cell.style.animation = 'attack 0.4s ease';
                        setTimeout(() => {
                            cell.style.animation = '';
                        }, 400);
                    }
                });
            });
        }

        function handleGameEnd(data) {
            const isWinner = data.winner === '{{ user.username }}';
            showGameOverModal(isWinner, data.rewards);
        }

        // Game logic
        let newTilePosition = null;

        function addRandomTile() {
            const emptyCells = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 0) {
                        emptyCells.push({x: i, y: j});
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                grid[randomCell.x][randomCell.y] = Math.random() < 0.9 ? 2 : 4;
                newTilePosition = randomCell;
            }
        }

        function updateDisplay() {
            const gridElement = document.getElementById('gameGrid');
            gridElement.innerHTML = '';
            
            let cellIndex = 0;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    const value = grid[i][j];
                    if (value !== 0) {
                        cell.textContent = value;
                        cell.setAttribute('data-value', value);
                        
                        // Add pop-in animation to new tiles
                        if (newTilePosition && newTilePosition.x === i && newTilePosition.y === j) {
                            cell.classList.add('new-tile');
                            setTimeout(() => {
                                cell.classList.remove('new-tile');
                                newTilePosition = null;
                            }, 300);
                        }
                    }
                    gridElement.appendChild(cell);
                    cellIndex++;
                }
            }
            
            document.getElementById('yourScore').textContent = score;
            document.getElementById('player1Score').textContent = score;
            updateMiniBoard('player1MiniBoard', grid);
        }

        function updateMiniBoard(elementId, board) {
            const miniBoard = document.getElementById(elementId);
            const existingCells = miniBoard.querySelectorAll('.mini-cell');
            let cellIndex = 0;
            
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const value = board[i][j];
                    const cell = existingCells[cellIndex];
                    
                    if (cell) {
                        const oldValue = cell.getAttribute('data-value');
                        const newValue = value.toString();
                        
                        // Only update if value changed
                        if (oldValue !== newValue) {
                            // Animate the change
                            cell.style.transition = 'all 0.2s ease';
                            cell.style.transform = 'scale(1.2)';
                            
                            setTimeout(() => {
                                if (value !== 0) {
                                    cell.textContent = value >= 1000 ? `${Math.floor(value/1000)}k` : value;
                                    cell.setAttribute('data-value', value);
                                } else {
                                    cell.textContent = '';
                                    cell.removeAttribute('data-value');
                                }
                                cell.style.transform = 'scale(1)';
                            }, 100);
                        } else if (value === 0) {
                            cell.textContent = '';
                            cell.removeAttribute('data-value');
                        } else {
                            cell.textContent = value >= 1000 ? `${Math.floor(value/1000)}k` : value;
                            cell.setAttribute('data-value', value);
                        }
                    }
                    cellIndex++;
                }
            }
        }

        function move(direction) {
            let moved = false;
            const mergedTiles = [];
            const oldGrid = JSON.parse(JSON.stringify(grid));
            
            // Movement logic for all directions
            if (direction === 'left') {
                for (let i = 0; i < 4; i++) {
                    const row = grid[i].filter(val => val !== 0);
                    for (let j = 0; j < row.length - 1; j++) {
                        if (row[j] === row[j + 1]) {
                            row[j] *= 2;
                            score += row[j];
                            mergedTiles.push(row[j]);
                            row.splice(j + 1, 1);
                        }
                    }
                    while (row.length < 4) row.push(0);
                    grid[i] = row;
                }
            } else if (direction === 'right') {
                for (let i = 0; i < 4; i++) {
                    const row = grid[i].filter(val => val !== 0);
                    for (let j = row.length - 1; j > 0; j--) {
                        if (row[j] === row[j - 1]) {
                            row[j] *= 2;
                            score += row[j];
                            mergedTiles.push(row[j]);
                            row.splice(j - 1, 1);
                            j--;
                        }
                    }
                    while (row.length < 4) row.unshift(0);
                    grid[i] = row;
                }
            } else if (direction === 'up') {
                for (let j = 0; j < 4; j++) {
                    const col = [];
                    for (let i = 0; i < 4; i++) {
                        if (grid[i][j] !== 0) col.push(grid[i][j]);
                    }
                    for (let i = 0; i < col.length - 1; i++) {
                        if (col[i] === col[i + 1]) {
                            col[i] *= 2;
                            score += col[i];
                            mergedTiles.push(col[i]);
                            col.splice(i + 1, 1);
                        }
                    }
                    while (col.length < 4) col.push(0);
                    for (let i = 0; i < 4; i++) {
                        grid[i][j] = col[i];
                    }
                }
            } else if (direction === 'down') {
                for (let j = 0; j < 4; j++) {
                    const col = [];
                    for (let i = 0; i < 4; i++) {
                        if (grid[i][j] !== 0) col.push(grid[i][j]);
                    }
                    for (let i = col.length - 1; i > 0; i--) {
                        if (col[i] === col[i - 1]) {
                            col[i] *= 2;
                            score += col[i];
                            mergedTiles.push(col[i]);
                            col.splice(i - 1, 1);
                            i--;
                        }
                    }
                    while (col.length < 4) col.unshift(0);
                    for (let i = 0; i < 4; i++) {
                        grid[i][j] = col[i];
                    }
                }
            }
            
            // Check if grid changed
            moved = JSON.stringify(oldGrid) !== JSON.stringify(grid);
            
            if (moved) {
                // Play move sound
                playMoveSound();
                
                // Play merge sounds and add animations
                if (mergedTiles.length > 0) {
                    mergedTiles.forEach((value, index) => {
                        setTimeout(() => playMergeSound(value), index * 50);
                    });
                }
                
                addRandomTile();
                updateDisplay();
                
                // Add sliding animation to all cells
                document.querySelectorAll('.cell[data-value]').forEach(cell => {
                    cell.classList.add('sliding');
                    setTimeout(() => cell.classList.remove('sliding'), 150);
                });
                
                // In multiplayer, handle attacks/heals
                if (gameMode === 'multiplayer' && mergedTiles.length > 0) {
                    handleMerge(mergedTiles);
                }
                
                // Check for 2048 win
                if (hasWon()) {
                    setTimeout(() => {
                        if (gameMode === 'multiplayer') {
                            endGame(true, '2048');
                        } else {
                            submitStandardScore();
                        }
                    }, 500);
                }
                
                // Check for game over
                if (isGameOver()) {
                    setTimeout(() => {
                        if (gameMode === 'multiplayer') {
                            endGame(false);
                        } else {
                            submitStandardScore();
                        }
                    }, 500);
                }
            }
        }

        function handleMerge(mergedTiles) {
            let totalDamage = 0;
            let totalHeal = 0;
            
            // Calculate damage and heal based on merged tiles
            mergedTiles.forEach(tile => {
                totalDamage += calculateDamage(tile);
                totalHeal += calculateHeal(tile);
            });
            
            // Apply heal to self
            player1Health = Math.min(100, player1Health + totalHeal);
            updateHealthBar('player1', player1Health);
            
            if (totalHeal > 0) {
                showHealEffect(document.querySelector('.player-panel'));
                showHealIndicator(`+${totalHeal}%`, document.querySelector('.player-panel'));
            }
            
            // Apply damage to opponent
            player2Health = Math.max(0, player2Health - totalDamage);
            updateHealthBar('player2', player2Health);
            
            if (totalDamage > 0) {
                showBombEffect(document.querySelectorAll('.player-panel')[1]);
                showDamageIndicator(`-${totalDamage}%`, document.querySelectorAll('.player-panel')[1]);
            }
            
            // Send move to server
            if (gameSocket && gameSocket.readyState === WebSocket.OPEN) {
                gameSocket.send(JSON.stringify({
                    type: 'move',
                    merged_tiles: mergedTiles,
                    score: score,
                    board: grid
                }));
            }
            
            // Check if opponent is defeated
            if (player2Health <= 0) {
                setTimeout(() => endGame(true), 1000);
            }
        }

        function calculateDamage(tileValue) {
            const damageMap = {
                4: 1, 8: 1, 16: 2, 32: 3, 64: 4,
                128: 5, 256: 8, 512: 10, 1024: 15, 2048: 25
            };
            return damageMap[tileValue] || 0;
        }

        function calculateHeal(tileValue) {
            const healMap = {
                4: 1, 8: 1, 16: 2, 32: 2, 64: 3,
                128: 4, 256: 5, 512: 6, 1024: 8, 2048: 12
            };
            return healMap[tileValue] || 0;
        }

        function updateHealthBar(player, health) {
            const healthBar = document.getElementById(`${player}HealthBar`);
            const healthText = document.getElementById(`${player}HealthText`);
            
            healthBar.style.width = health + '%';
            healthBar.textContent = health + '%';
            healthText.textContent = health + '%';
            
            // Change color based on health
            healthBar.classList.remove('low', 'critical');
            if (health <= 30) {
                healthBar.classList.add('critical');
            } else if (health <= 50) {
                healthBar.classList.add('low');
            }
        }

        // Visual effects
        function showBombEffect(element) {
            const rect = element.getBoundingClientRect();
            const effect = document.createElement('div');
            effect.className = 'bomb-effect';
            effect.style.left = rect.left + rect.width / 2 - 50 + 'px';
            effect.style.top = rect.top + rect.height / 2 - 50 + 'px';
            document.body.appendChild(effect);
            
            // Play sound
            playSound('bomb');
            
            setTimeout(() => effect.remove(), 600);
        }

        function showHealEffect(element) {
            const rect = element.getBoundingClientRect();
            const effect = document.createElement('div');
            effect.className = 'heal-effect';
            effect.style.left = rect.left + rect.width / 2 - 40 + 'px';
            effect.style.top = rect.top + rect.height / 2 - 40 + 'px';
            document.body.appendChild(effect);
            
            // Play sound
            playSound('heal');
            
            setTimeout(() => effect.remove(), 600);
        }

        function showDamageIndicator(text, element) {
            const rect = element.getBoundingClientRect();
            const indicator = document.createElement('div');
            indicator.className = 'damage-indicator';
            indicator.textContent = text;
            indicator.style.left = rect.left + rect.width / 2 - 30 + 'px';
            indicator.style.top = rect.top + 20 + 'px';
            document.body.appendChild(indicator);
            
            setTimeout(() => indicator.remove(), 1000);
        }

        function showHealIndicator(text, element) {
            const rect = element.getBoundingClientRect();
            const indicator = document.createElement('div');
            indicator.className = 'heal-indicator';
            indicator.textContent = text;
            indicator.style.left = rect.left + rect.width / 2 - 30 + 'px';
            indicator.style.top = rect.top + 20 + 'px';
            document.body.appendChild(indicator);
            
            setTimeout(() => indicator.remove(), 1000);
        }

        function playSound(type) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            if (type === 'bomb') {
                oscillator.frequency.value = 100;
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } else if (type === 'heal') {
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            }
        }

        // Game end
        function hasWon() {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 2048) return true;
                }
            }
            return false;
        }

        function isGameOver() {
            // Check for empty cells
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 0) return false;
                }
            }
            
            // Check for possible merges
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (j < 3 && grid[i][j] === grid[i][j + 1]) return false;
                    if (i < 3 && grid[i][j] === grid[i + 1][j]) return false;
                }
            }
            
            return true;
        }

        function endGame(isWinner, reason = 'health') {
            if (gameSocket && gameSocket.readyState === WebSocket.OPEN) {
                gameSocket.send(JSON.stringify({
                    type: 'game_over',
                    winner: isWinner ? '{{ user.username }}' : (isBot ? '2048_BOT' : 'opponent'),
                    reason: reason
                }));
            }
            
            // Calculate rewards
            const rewards = {
                base: Math.min(200, Math.max(50, score / 50)),
                win_bonus: isWinner ? 100 : 0,
                health_bonus: isWinner ? Math.floor(player1Health / 2) : 0,
                total: 0
            };
            rewards.total = rewards.base + rewards.win_bonus + rewards.health_bonus;
            
            showGameOverModal(isWinner, rewards);
        }

        function showGameOverModal(isWinner, rewards) {
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('modalTitle');
            const stats = document.getElementById('modalStats');
            const rewardsDiv = document.getElementById('modalRewards');
            
            // Play victory or defeat sound
            if (isWinner) {
                playVictorySound();
            } else {
                playDefeatSound();
            }
            
            title.textContent = isWinner ? 'üèÜ VICTORY!' : 'üíÄ DEFEAT!';
            title.className = isWinner ? 'modal-title victory' : 'modal-title defeat';
            
            stats.innerHTML = `
                <div>Final Score: ${score}</div>
                <div>Your Health: ${player1Health}%</div>
                <div>Opponent Health: ${player2Health}%</div>
            `;
            
            if (isWinner && rewards) {
                rewardsDiv.innerHTML = `
                    <div class="reward-item">
                        <span>Base Reward</span>
                        <span>${rewards.base} üí∞</span>
                    </div>
                    <div class="reward-item">
                        <span>Victory Bonus</span>
                        <span>${rewards.win_bonus} üí∞</span>
                    </div>
                    <div class="reward-item">
                        <span>Health Bonus</span>
                        <span>${rewards.health_bonus} üí∞</span>
                    </div>
                    <div class="reward-item">
                        <span>Total Earned</span>
                        <span>${rewards.total} üí∞</span>
                    </div>
                `;
            } else {
                rewardsDiv.innerHTML = '<div style="text-align: center; padding: 20px;">Better luck next time!</div>';
            }
            
            modal.style.display = 'flex';
        }

        function submitStandardScore() {
            // Submit score for standard mode
            const playTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const baseReward = Math.min(200, score / 10);
            
            // Milestone bonuses
            let milestoneBonus = 0;
            const highestTile = Math.max(...grid.flat());
            if (highestTile >= 512) milestoneBonus += 25;
            if (highestTile >= 1024) milestoneBonus += 50;
            if (highestTile >= 2048) milestoneBonus += 100;
            
            const totalReward = Math.floor(Math.min(200, baseReward + milestoneBonus));
            
            fetch('/games/submit-score/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    game_type: '2048',
                    score: score,
                    play_time: playTime,
                    reward: totalReward
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`Game Over!\n\nFinal Score: ${score}\nEvercoins Earned: ${totalReward} üí∞\n\nYour Total: ${data.new_balance} üí∞`);
                    location.reload();
                } else {
                    alert('Error submitting score: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error submitting score:', error);
                alert('Error submitting score. Please try again.');
            });
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function forfeitGame() {
            if (confirm('Are you sure you want to forfeit? You will lose the match.')) {
                endGame(false);
            }
        }

        function newGame() {
            if (gameMode === 'multiplayer') {
                if (confirm('Start a new multiplayer match?')) {
                    location.reload();
                }
            }
        }

        function playAgain() {
            location.reload();
        }

        function backToMenu() {
            closeGameWindow();
        }

        function closeGameWindow() {
            // If window was opened by another window, close it
            if (window.opener && !window.opener.closed) {
                window.opener.focus();
                window.close();
            } else {
                // Otherwise redirect
                window.location.href = '/chat/';
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                const direction = e.key.replace('Arrow', '').toLowerCase();
                move(direction);
            }
        });

        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 50) move('right');
                else if (dx < -50) move('left');
            } else {
                if (dy > 50) move('down');
                else if (dy < -50) move('up');
            }
        });

        // Initialize mini boards on load
        document.addEventListener('DOMContentLoaded', () => {
            for (let i = 0; i < 16; i++) {
                const cell1 = document.createElement('div');
                cell1.className = 'mini-cell';
                document.getElementById('player1MiniBoard').appendChild(cell1);
                
                const cell2 = document.createElement('div');
                cell2.className = 'mini-cell';
                document.getElementById('player2MiniBoard').appendChild(cell2);
            }
            
            // Initialize game grid
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                document.getElementById('gameGrid').appendChild(cell);
            }
        });

        // Bot AI - Simulates opponent moves
        let botInterval = null;
        let botGrid = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
        let botScore = 0;

        function startBotAI() {
            // Initialize bot's board
            botGrid = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
            botScore = 0;
            addRandomBotTile();
            addRandomBotTile();
            
            // Bot makes moves every 2-4 seconds
            botInterval = setInterval(() => {
                if (player2Health > 0 && player1Health > 0) {
                    makeBotMove();
                } else {
                    clearInterval(botInterval);
                }
            }, 2000 + Math.random() * 2000);
        }

        function addRandomBotTile() {
            const emptyCells = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (botGrid[i][j] === 0) {
                        emptyCells.push({x: i, y: j});
                    }
                }
            }
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                botGrid[randomCell.x][randomCell.y] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        function makeBotMove() {
            const directions = ['left', 'right', 'up', 'down'];
            const validMoves = [];
            
            // Test each direction
            directions.forEach(dir => {
                const testGrid = JSON.parse(JSON.stringify(botGrid));
                if (canBotMove(testGrid, dir)) {
                    validMoves.push(dir);
                }
            });
            
            if (validMoves.length === 0) {
                console.log('ü§ñ Bot has no valid moves - Bot loses!');
                player2Health = 0;
                updateHealthBar('player2', 0);
                setTimeout(() => endGame(true), 1000);
                clearInterval(botInterval);
                return;
            }
            
            // Make random valid move
            const direction = validMoves[Math.floor(Math.random() * validMoves.length)];
            const result = executeBotMove(direction);
            
            if (result.moved) {
                addRandomBotTile();
                botScore = result.score;
                
                console.log('ü§ñ Bot moved:', direction, 'Score:', botScore, 'Merged:', result.mergedTiles);
                
                // Simulate bot sending move through WebSocket
                simulateBotMove(result);
            }
        }

        function canBotMove(testGrid, direction) {
            const oldGrid = JSON.parse(JSON.stringify(testGrid));
            
            // Simplified move check
            if (direction === 'left' || direction === 'right') {
                for (let i = 0; i < 4; i++) {
                    const row = testGrid[i].filter(v => v !== 0);
                    if (direction === 'right') row.reverse();
                    for (let j = 0; j < row.length - 1; j++) {
                        if (row[j] === row[j + 1]) return true;
                    }
                }
            } else {
                for (let j = 0; j < 4; j++) {
                    const col = [];
                    for (let i = 0; i < 4; i++) {
                        if (testGrid[i][j] !== 0) col.push(testGrid[i][j]);
                    }
                    if (direction === 'down') col.reverse();
                    for (let i = 0; i < col.length - 1; i++) {
                        if (col[i] === col[i + 1]) return true;
                    }
                }
            }
            
            return JSON.stringify(oldGrid) !== JSON.stringify(testGrid);
        }

        function executeBotMove(direction) {
            const mergedTiles = [];
            let tempScore = botScore;
            
            if (direction === 'left') {
                for (let i = 0; i < 4; i++) {
                    const row = botGrid[i].filter(val => val !== 0);
                    for (let j = 0; j < row.length - 1; j++) {
                        if (row[j] === row[j + 1]) {
                            row[j] *= 2;
                            tempScore += row[j];
                            mergedTiles.push(row[j]);
                            row.splice(j + 1, 1);
                        }
                    }
                    while (row.length < 4) row.push(0);
                    botGrid[i] = row;
                }
            } else if (direction === 'right') {
                for (let i = 0; i < 4; i++) {
                    const row = botGrid[i].filter(val => val !== 0);
                    for (let j = row.length - 1; j > 0; j--) {
                        if (row[j] === row[j - 1]) {
                            row[j] *= 2;
                            tempScore += row[j];
                            mergedTiles.push(row[j]);
                            row.splice(j - 1, 1);
                            j--;
                        }
                    }
                    while (row.length < 4) row.unshift(0);
                    botGrid[i] = row;
                }
            } else if (direction === 'up') {
                for (let j = 0; j < 4; j++) {
                    const col = [];
                    for (let i = 0; i < 4; i++) {
                        if (botGrid[i][j] !== 0) col.push(botGrid[i][j]);
                    }
                    for (let i = 0; i < col.length - 1; i++) {
                        if (col[i] === col[i + 1]) {
                            col[i] *= 2;
                            tempScore += col[i];
                            mergedTiles.push(col[i]);
                            col.splice(i + 1, 1);
                        }
                    }
                    while (col.length < 4) col.push(0);
                    for (let i = 0; i < 4; i++) {
                        botGrid[i][j] = col[i];
                    }
                }
            } else if (direction === 'down') {
                for (let j = 0; j < 4; j++) {
                    const col = [];
                    for (let i = 0; i < 4; i++) {
                        if (botGrid[i][j] !== 0) col.push(botGrid[i][j]);
                    }
                    for (let i = col.length - 1; i > 0; i--) {
                        if (col[i] === col[i - 1]) {
                            col[i] *= 2;
                            tempScore += col[i];
                            mergedTiles.push(col[i]);
                            col.splice(i - 1, 1);
                            i--;
                        }
                    }
                    while (col.length < 4) col.unshift(0);
                    for (let i = 0; i < 4; i++) {
                        botGrid[i][j] = col[i];
                    }
                }
            }
            
            return {
                moved: mergedTiles.length > 0,
                score: tempScore,
                mergedTiles: mergedTiles
            };
        }

        function simulateBotMove(result) {
            // Calculate damage to player
            let totalDamage = 0;
            let totalHeal = 0;
            
            result.mergedTiles.forEach(tile => {
                totalDamage += calculateDamage(tile);
                totalHeal += calculateHeal(tile);
            });
            
            // Bot heals itself
            player2Health = Math.min(100, player2Health + totalHeal);
            updateHealthBar('player2', player2Health);
            
            if (totalHeal > 0) {
                showHealEffect(document.querySelectorAll('.player-panel')[1]);
                showHealIndicator(`+${totalHeal}%`, document.querySelectorAll('.player-panel')[1]);
            }
            
            // Bot damages player
            player1Health = Math.max(0, player1Health - totalDamage);
            updateHealthBar('player1', player1Health);
            
            if (totalDamage > 0) {
                showBombEffect(document.querySelector('#player1HealthBar'));
                showDamageIndicator(`-${totalDamage}%`, document.querySelector('.player-panel'));
                
                const healthBar = document.querySelector('#player1HealthBar');
                healthBar.parentElement.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    healthBar.parentElement.style.animation = '';
                }, 500);
            }
            
            // Update bot display
            document.getElementById('player2Score').textContent = result.score;
            updateMiniBoard('player2MiniBoard', botGrid);
            
            // Show activity
            const activityIndicator = document.getElementById('opponentActivity');
            if (activityIndicator) {
                activityIndicator.classList.add('active');
                setTimeout(() => {
                    activityIndicator.classList.remove('active');
                }, 2000);
            }
            
            // Highlight bot's move
            highlightOpponentMerges(result.mergedTiles);
            
            // Check if player lost
            if (player1Health <= 0) {
                clearInterval(botInterval);
                setTimeout(() => endGame(false), 1000);
            }
        }
    </script>
</body>
</html>
